<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>plugins/axis/jqplot.categoryAxisRenderer.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="$.jqplot.CanvasFontRenderer.html">CanvasFontRenderer</a><ul class='methods'><li data-type='method'><a href="$.jqplot.CanvasFontRenderer.html#draw">draw</a></li><li data-type='method'><a href="$.jqplot.CanvasFontRenderer.html#measure">measure</a></li></ul></li><li><a href="$.jqplot.CanvasOverlay.html">CanvasOverlay</a><ul class='methods'><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#.postPlotDraw">postPlotDraw</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#.postPlotInit">postPlotInit</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addDashedHorizontalLine">addDashedHorizontalLine</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addDashedVerticalLine">addDashedVerticalLine</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addHorizontalLine">addHorizontalLine</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addLine">addLine</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addRectangle">addRectangle</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addVerticalLine">addVerticalLine</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addWorkItem">addWorkItem</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#clear">clear</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#draw">draw</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#getObject">getObject</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#removeObject">removeObject</a></li></ul></li><li><a href="$.jqplot.CanvasTextRenderer.html">CanvasTextRenderer</a><ul class='methods'><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#draw">draw</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#fontWeight2Float">fontWeight2Float</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#getHeight">getHeight</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#getText">getText</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#getWidth">getWidth</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#init">init</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#letter">letter</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#measure">measure</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#normalizeFontSize">normalizeFontSize</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#setHeight">setHeight</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#setText">setText</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#setWidth">setWidth</a></li></ul></li><li><a href="$.jqplot.EnhancedLegendRenderer.html">EnhancedLegendRenderer</a><ul class='methods'><li data-type='method'><a href="$.jqplot.EnhancedLegendRenderer.html#draw">draw</a></li><li data-type='method'><a href="$.jqplot.EnhancedLegendRenderer.html#init">init</a></li></ul></li><li><a href="Class_%2520jqPlot%250APlot%2520object%2520returned%2520by%2520call%2520to%2520$.jqplot.%2520%2520Handles%2520parsing%2520user%2520options,%250Acreating%2520sub%2520objects%2520(Axes,%2520legend,%2520title,%2520series)%2520and%2520rendering%2520the%2520plot..html">Class: jqPlot
Plot object returned by call to $.jqplot.  Handles parsing user options,
creating sub objects (Axes, legend, title, series) and rendering the plot.</a></li><li><a href="DashedHorizontalLine.html">DashedHorizontalLine</a></li><li><a href="DashedVerticalLine.html">DashedVerticalLine</a></li><li><a href="HorizontalLine.html">HorizontalLine</a></li><li><a href="jsDate.html">jsDate</a></li><li><a href="Line.html">Line</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="VerticalLine.html">VerticalLine</a></li><li><a href="WorkItem.html">WorkItem</a></li></ul><h3>Namespaces</h3><ul><li><a href="Configuration%2520options%2520that%2520will%2520be%2520used%2520as%2520defaults%2520for%2520all%2520instances%2520on%2520the%2520page..html">Configuration options that will be used as defaults for all instances on the page.</a></li><li><a href="Holds%2520localizations%2520for%2520month_day%2520names.%250A_p_jsDate%2520attempts%2520to%2520detect%2520locale%2520when%2520loaded%2520and%2520defaults%2520to%2520_en_.%250AIf%2520a%2520localization%2520is%2520detected%2520which%2520is%2520not%2520available,%2520jsDate%2520defaults%2520to%2520_en_.%250AAdditional%2520localizations%2520can%2520be%2520added%2520after%2520jsDate%2520loads.%2520%2520After%2520adding%2520a%2520localization,%250Acall%2520the%2520jsDate.regional.getLocale()%2520method.%2520%2520Currently,%2520en,%2520fr%2520and%2520de%2520are%2520defined.__p_%250A%250A_p_Localizations%2520must%2520be%2520an%2520object%2520and%2520have%2520the%2520following%2520properties%2520defined_%2520%2520monthNames,%2520monthNamesShort,%2520dayNames,%2520dayNamesShort%2520and%2520Localizations%2520are%2520added%2520like___p_%250A_pre%2520class=_code__%250AjsDate.regional._en_%2520=%2520%257B%250AmonthNames%2520%2520%2520%2520%2520%2520_%2520_January%2520February%2520March%2520April%2520May%2520June%2520July%2520August%2520September%2520October%2520November%2520December_.split(_%2520_),%250AmonthNamesShort%2520_%2520_Jan%2520Feb%2520Mar%2520Apr%2520May%2520Jun%2520Jul%2520Aug%2520Sep%2520Oct%2520Nov%2520Dec_.split(_%2520_),%250AdayNames%2520%2520%2520%2520%2520%2520%2520%2520_%2520_Sunday%2520Monday%2520Tuesday%2520Wednesday%2520Thursday%2520Friday%2520Saturday_.split(_%2520_),%250AdayNamesShort%2520%2520%2520_%2520_Sun%2520Mon%2520Tue%2520Wed%2520Thu%2520Fri%2520Sat_.split(_%2520_)%250A%257D;%250A__pre_%250A_p_After%2520adding%2520localizations,%2520call%2520_code_jsDate.regional.getLocale();__code_%2520to%2520update%2520the%2520locale%2520setting%2520with%2520the%250Anew%2520localizations.__p_.html">Holds localizations for month/day names.
<p>jsDate attempts to detect locale when loaded and defaults to 'en'.
If a localization is detected which is not available, jsDate defaults to 'en'.
Additional localizations can be added after jsDate loads.  After adding a localization,
call the jsDate.regional.getLocale() method.  Currently, en, fr and de are defined.</p>

<p>Localizations must be an object and have the following properties defined:  monthNames, monthNamesShort, dayNames, dayNamesShort and Localizations are added like:</p>
<pre class="code">
jsDate.regional['en'] = {
monthNames      : 'January February March April May June July August September October November December'.split(' '),
monthNamesShort : 'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec'.split(' '),
dayNames        : 'Sunday Monday Tuesday Wednesday Thursday Friday Saturday'.split(' '),
dayNamesShort   : 'Sun Mon Tue Wed Thu Fri Sat'.split(' ')
};
</pre>
<p>After adding localizations, call <code>jsDate.regional.getLocale();</code> to update the locale setting with the
new localizations.</p></a></li><li><a href="Namespace%2520to%2520hold%2520format%2520codes%2520and%2520format%2520shortcuts.%2520%2520_perl_%2520and%2520_php_%2520format%2520codes%2520%250Aand%2520shortcuts%2520are%2520defined%2520by%2520default.%2520%2520Additional%2520codes%2520and%2520shortcuts%2520can%2520be%250Aadded%2520like_%250A%250A_pre%2520class=_code__%250AjsDate.formats._perl_%2520=%2520%257B%250A%2520%2520%2520%2520_codes__%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520matcher_%2520_someregex_,%250A%2520%2520%2520%2520%2520%2520%2520%2520Y_%2520_fullYear_,%2520%2520__%2520name%2520of%2520_get_%2520method%2520without%2520the%2520_get_,%250A%2520%2520%2520%2520%2520%2520%2520%2520...,%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520__%2520more%2520codes%250A%2520%2520%2520%2520%257D,%250A%2520%2520%2520%2520_shortcuts__%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520F_%2520_%2525Y-%2525m-%2525d_,%250A%2520%2520%2520%2520%2520%2520%2520%2520...,%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520__%2520more%2520shortcuts%250A%2520%2520%2520%2520%257D%250A%257D;%250A__pre_%250A%250A_p_Additionally,%2520ISO%2520and%2520SQL%2520shortcuts%2520are%2520defined%2520and%2520can%2520be%2520accesses%2520via_%250A_code_jsDate.formats.ISO__code_%2520and%2520_code_jsDate.formats.SQL__code_.html">Namespace to hold format codes and format shortcuts.  "perl" and "php" format codes 
and shortcuts are defined by default.  Additional codes and shortcuts can be
added like:

<pre class="code">
jsDate.formats["perl"] = {
    "codes": {
        matcher: /someregex/,
        Y: "fullYear",  // name of "get" method without the "get",
        ...,            // more codes
    },
    "shortcuts": {
        F: '%Y-%m-%d',
        ...,            // more shortcuts
    }
};
</pre>

<p>Additionally, ISO and SQL shortcuts are defined and can be accesses via:
<code>jsDate.formats.ISO</code> and <code>jsDate.formats.SQL</code></a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">plugins/axis/jqplot.categoryAxisRenderer.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*jslint browser: true, plusplus: true, nomen: true, white: false */
/*global jQuery, console, jqPlot */

/**
 * jqPlot
 * Pure JavaScript plotting plugin using jQuery
 *
 * Version: @VERSION
 * Revision: @REVISION
 *
 * Copyright (c) 2009-2013 Chris Leonello
 * jqPlot is currently available for use in all personal or commercial projects 
 * under both the MIT (http://www.opensource.org/licenses/mit-license.php) and GPL 
 * version 2.0 (http://www.gnu.org/licenses/gpl-2.0.html) licenses. This means that you can 
 * choose the license that best suits your project and use it accordingly. 
 *
 * Although not required, the author would appreciate an email letting him 
 * know of any substantial use of jqPlot.  You can reach the author at: 
 * chris at jqplot dot com or see http://www.jqplot.com/info.php .
 *
 * If you are feeling kind and generous, consider supporting the project by
 * making a donation at: http://www.jqplot.com/donate.php .
 *
 * sprintf functions contained in jqplot.sprintf.js by Ash Searle:
 *
 *     version 2007.04.27
 *     author Ash Searle
 *     http://hexmen.com/blog/2007/03/printf-sprintf/
 *     http://hexmen.com/js/sprintf.js
 *     The author (Ash Searle) has placed this code in the public domain:
 *     "This code is unrestricted: you are free to use it however you like."
 * 
 */
(function ($) {
    
    "use strict";
    
    /**
    *  class: $.jqplot.CategoryAxisRenderer
    *  A plugin for jqPlot to render a category style axis, with equal pixel spacing between y data values of a series.
    *  
    *  To use this renderer, include the plugin in your source
    *  > &lt;script type="text/javascript" language="javascript" src="plugins/jqplot.categoryAxisRenderer.js">&lt;/script>
    *  
    *  and supply the appropriate options to your plot
    *  
    *  > { axes: { xaxis:{ renderer: $.jqplot.CategoryAxisRenderer}}}
    **/
    $.jqplot.CategoryAxisRenderer = function (options) {
        $.jqplot.LinearAxisRenderer.call(this);
        // prop: sortMergedLabels
        // True to sort tick labels when labels are created by merging
        // x axis values from multiple series.  That is, say you have
        // two series like:
        // > line1 = [[2006, 4],            [2008, 9], [2009, 16]];
        // > line2 = [[2006, 3], [2007, 7], [2008, 6]];
        // If no label array is specified, tick labels will be collected
        // from the x values of the series.  With sortMergedLabels
        // set to true, tick labels will be:
        // > [2006, 2007, 2008, 2009]
        // With sortMergedLabels set to false, tick labels will be:
        // > [2006, 2008, 2009, 2007]
        //
        // Note, this property is specified on the renderOptions for the 
        // axes when creating a plot:
        // > axes:{xaxis:{renderer:$.jqplot.CategoryAxisRenderer, rendererOptions:{sortMergedLabels:true}}}
        this.sortMergedLabels = false;
    };
    
    $.jqplot.CategoryAxisRenderer.prototype = new $.jqplot.LinearAxisRenderer();
    $.jqplot.CategoryAxisRenderer.prototype.constructor = $.jqplot.CategoryAxisRenderer;
    
    /**
     * @param {object} options
     */
    $.jqplot.CategoryAxisRenderer.prototype.init = function (options) {
        
        var db,
            i,
            j,
            s,
            d,
            seriesLen;
        
        this.groups = 1;
        this.groupLabels = [];
        this._groupLabels = [];
        this._grouped = false;
        this._barsPerGroup = null;
        this.reverse = false;
        
        // prop: tickRenderer
        // A class of a rendering engine for creating the ticks labels displayed on the plot, 
        // See &lt;$.jqplot.AxisTickRenderer>.
        // this.tickRenderer = $.jqplot.AxisTickRenderer;
        // this.labelRenderer = $.jqplot.AxisLabelRenderer;
        $.extend(true, this, {tickOptions: { formatString: '%d' }}, options);
        
        db = this._dataBounds;
        
        // Go through all the series attached to this axis and find
        // the min/max bounds for this axis.
        for (i = 0, seriesLen = this._series.length; i &lt; seriesLen; i++) {
            s = this._series[i];
            if (s.groups) {
                this.groups = s.groups;
            }
            d = s.data;
            for (j = 0; j &lt; d.length; j++) {
                if (this.name === 'xaxis' || this.name === 'x2axis') {
                    if (db.min === null || d[j][0] &lt; db.min) {
                        db.min = d[j][0];
                    }
                    if (db.max === null || d[j][0] > db.max) {
                        db.max = d[j][0];
                    }
                } else {
                    if (db.min === null || d[j][1] &lt; db.min) {
                        db.min = d[j][1];
                    }
                    if (db.max === null || d[j][1] > db.max) {
                        db.max = d[j][1];
                    }
                }
            }
        }
        
        if (this.groupLabels.length) {
            this.groups = this.groupLabels.length;
        }
    };
 
    /**
     */
    $.jqplot.CategoryAxisRenderer.prototype.createTicks = function () {
        
        var ticks,
            userTicks,
            name,
            db,
            dim,
            interval,
            min,
            max,
            pos1,
            pos2,
            tt,
            i,
            j,
            skip,
            l,
            t,
            s,
            count,
            range,
            labels,
            numcats,
            isMerged,
            idx,
            labelsLen,
            track,
            maxVisibleTicks,
            val;
        
        // we're are operating on an axis here
        ticks = this._ticks;
        userTicks = this.ticks;
        name = this.name;
        // databounds were set on axis initialization.
        db = this._dataBounds;

        // if we already have ticks, use them.
        if (userTicks.length) {
            
            // adjust with blanks if we have groups
            if (this.groups > 1 &amp;&amp; !this._grouped) {
                l = userTicks.length;
                skip = parseInt(l / this.groups, 10);
                count = 0;
                for (i = skip; i &lt; l; i += skip) {
                    userTicks.splice(i + count, 0, ' ');
                    count++;
                }
                this._grouped = true;
            }
            
            this.min = 0.5;
            this.max = userTicks.length + 0.5;
            range = this.max - this.min;
            this.numberTicks = 2 * userTicks.length + 1;
            
            for (i = 0; i &lt; userTicks.length; i++) {
                tt = this.min + 2 * i * range / (this.numberTicks - 1);
                // need a marker before and after the tick
                t = new this.tickRenderer(this.tickOptions);
                t.showLabel = false;
                // t.showMark = true;
                t.setTick(tt, this.name);
                this._ticks.push(t);
                t = new this.tickRenderer(this.tickOptions);
                t.label = userTicks[i];
                // t.showLabel = true;
                t.showMark = false;
                t.showGridline = false;
                t.setTick(tt + 0.5, this.name);
                this._ticks.push(t);
            }
            // now add the last tick at the end
            t = new this.tickRenderer(this.tickOptions);
            t.showLabel = false;
            // t.showMark = true;
            t.setTick(tt + 1, this.name);
            this._ticks.push(t);
            
        // we don't have any ticks yet, let's make some!
        } else {
            
            if (name === 'xaxis' || name === 'x2axis') {
                dim = this._plotDimensions.width;
            } else {
                dim = this._plotDimensions.height;
            }
            
            // if min, max and number of ticks specified, user can't specify interval.
            if (this.min !== null &amp;&amp; this.max !== null &amp;&amp; this.numberTicks !== null) {
                this.tickInterval = null;
            }
            
            // if max, min, and interval specified and interval won't fit, ignore interval.
            if (this.min !== null &amp;&amp; this.max !== null &amp;&amp; this.tickInterval !== null) {
                if (parseInt((this.max - this.min) / this.tickInterval, 10) !== (this.max - this.min) / this.tickInterval) {
                    this.tickInterval = null;
                }
            }
        
            // find out how many categories are in the lines and collect labels
            labels = [];
            numcats = 0;
            min = 0.5;
            
            isMerged = false;
            
            for (i = 0; i &lt; this._series.length; i++) {
                
                s = this._series[i];
                
                for (j = 0; j &lt; s.data.length; j++) {
                    if (this.name === 'xaxis' || this.name === 'x2axis') {
                        val = s.data[j][0];
                    } else {
                        val = s.data[j][1];
                    }
                    if ($.inArray(val, labels) === -1) {
                        isMerged = true;
                        numcats += 1;
                        labels.push(val);
                    }
                }
            }
            
            if (isMerged &amp;&amp; this.sortMergedLabels) {
                if (typeof labels[0] === "string") {
                    labels.sort();
                } else {
                    labels.sort(function (a, b) { return a - b; });
                }
            }
            
            // keep a reference to these tick labels to use for redrawing plot (see bug #57)
            this.ticks = labels;
            
            // now bin the data values to the right lables.
            for (i = 0; i &lt; this._series.length; i++) {
                
                s = this._series[i];
                
                for (j = 0; j &lt; s.data.length; j++) {
                    if (this.name === 'xaxis' || this.name === 'x2axis') {
                        val = s.data[j][0];
                    } else {
                        val = s.data[j][1];
                    }
                    // for category axis, force the values into category bins.
                    // we should have the value in the label array now.
                    idx = $.inArray(val, labels) + 1;
                    if (this.name === 'xaxis' || this.name === 'x2axis') {
                        s.data[j][0] = idx;
                    } else {
                        s.data[j][1] = idx;
                    }
                }
            }
            
            // adjust with blanks if we have groups
            if (this.groups > 1 &amp;&amp; !this._grouped) {
                labelsLen = labels.length;
                skip = parseInt(labelsLen / this.groups, 10);
                count = 0;
                for (i = skip; i &lt; labelsLen; i += skip + 1) {
                    labels[i] = ' ';
                }
                this._grouped = true;
            }
        
            max = numcats + 0.5;
            
            if (this.numberTicks === null) {
                this.numberTicks = 2 * numcats + 1;
            }

            range = max - min;
            this.min = min;
            this.max = max;
            track = 0;
            
            // todo: adjust this so more ticks displayed.
            maxVisibleTicks = parseInt(3 + dim / 10, 10);
            skip = parseInt(numcats / maxVisibleTicks, 10);

            if (this.tickInterval == null) {
                this.tickInterval = range / (this.numberTicks - 1);
            }
            
            // if tickInterval is specified, we will ignore any computed maximum.
            for (i = 0; i &lt; this.numberTicks; i++) {
                tt = this.min + i * this.tickInterval;
                t = new this.tickRenderer(this.tickOptions);
                // if even tick, it isn't a category, it's a divider
                if (i / 2 === parseInt(i / 2, 10)) {
                    //console.log("rendering divider");
                    t.showLabel = false;
                    t.showMark = this.tickOptions.showMark;
                } else {
                    if (skip > 0 &amp;&amp; track &lt; skip) {
                        t.showLabel = false;
                        track += 1;
                    } else {
                        t.showLabel = true;
                        track = 0;
                    }
                    t.label = t.formatter(t.formatString, labels[(i - 1) / 2]);
                    t.showMark = false;
                    t.showGridline = false;
                }
                t.setTick(tt, this.name);
                this._ticks.push(t);
            }
        }
        
    };
    
    /**
     * called with scope of axis
     * @param {object} ctx
     * @param {object} plot
     */ 
    $.jqplot.CategoryAxisRenderer.prototype.draw = function (ctx, plot) {
        
        var dim,
            temp,
            t,
            i,
            elem,
            tick;
        
        if (!this.show) {
            return this._elem;
        }
        
        // populate the axis label and value properties.
        // createTicks is a method on the renderer, but
        // call it within the scope of the axis.
        this.renderer.createTicks.call(this);
        
        // fill a div with axes labels in the right direction.
        // Need to pregenerate each axis to get its bounds and
        // position it and the labels correctly on the plot.
        dim = 0;
        
        // Added for theming.
        if (this._elem) {
            // this._elem.empty();
            // Memory Leaks patch
            this._elem.emptyForce();
        }

        this._elem = this._elem || $('&lt;div class="jqplot-axis jqplot-' + this.name + '" style="position:absolute;">&lt;/div>');

        if (this.name === 'xaxis' || this.name === 'x2axis') {
            this._elem.width(this._plotDimensions.width);
        } else {
            this._elem.height(this._plotDimensions.height);
        }

        // create a _label object.
        this.labelOptions.axis = this.name;
        this._label = new this.labelRenderer(this.labelOptions);
        
        if (this._label.show) {
            elem = this._label.draw(ctx, plot);
            elem.appendTo(this._elem);
        }

        t = this._ticks;
        
        for (i = 0; i &lt; t.length; i++) {
            tick = t[i];
            if (tick.showLabel &amp;&amp; (!tick.isMinorTick || this.showMinorTicks)) {
                elem = tick.draw(ctx, plot);
                elem.appendTo(this._elem);
            }
        }

        this._groupLabels = [];
        
        // now make group labels
        // TODO there is a bug on categoryu renderer stack serie. Categories doesn't shows in axis.
        //console.log(this); 
        //this.groupLabels = this.ticks;
        for (i = 0; i &lt; this.groupLabels.length; i++) {
            elem = $('&lt;div style="position:absolute;" class="jqplot-' + this.name + '-groupLabel">&lt;/div>');
            elem.html(this.groupLabels[i]);
            this._groupLabels.push(elem);
            elem.appendTo(this._elem);
        }
        
        return this._elem;
        
    };
    
    /**
     * called with scope of axis
     */
    $.jqplot.CategoryAxisRenderer.prototype.set = function () {
        
        var dim,
            dim2,
            temp,
            w,
            h,
            lshow,
            t,
            i,
            l,
            tick;
        
        dim = 0;
        w = 0;
        h = 0;
        lshow = (this._label == null) ? false : this._label.show;
        
        if (!this.show) {
            return;
        }
        
        t = this._ticks;
        
        for (i = 0; i &lt; t.length; i++) {
            tick = t[i];
            if (tick.showLabel &amp;&amp; (!tick.isMinorTick || this.showMinorTicks)) {
                if (this.name === 'xaxis' || this.name === 'x2axis') {
                    temp = tick._elem.outerHeight(true);
                } else {
                    temp = tick._elem.outerWidth(true);
                }
                if (temp > dim) {
                    dim = temp;
                }
            }
        }

        dim2 = 0;
        
        for (i = 0; i &lt; this._groupLabels.length; i++) {
            l = this._groupLabels[i];
            if (this.name === 'xaxis' || this.name === 'x2axis') {
                temp = l.outerHeight(true);
            } else {
                temp = l.outerWidth(true);
            }
            if (temp > dim2) {
                dim2 = temp;
            }
        }

        if (lshow) {
            w = this._label._elem.outerWidth(true);
            h = this._label._elem.outerHeight(true);
        }
        
        if (this.name === 'xaxis') {
            dim += dim2 + h;
            this._elem.css({ 'height': dim + 'px', left : '0px', bottom: '0px'});
        } else if (this.name === 'x2axis') {
            dim += dim2 + h;
            this._elem.css({ 'height': dim + 'px', left: '0px', top: '0px'});
        } else if (this.name === 'yaxis') {
            dim += dim2 + w;
            this._elem.css({ 'width': dim + 'px', left: '0px', top: '0px'});
            if (lshow &amp;&amp; this._label.constructor === $.jqplot.AxisLabelRenderer) {
                this._label._elem.css('width', w + 'px');
            }
        } else {
            dim += dim2 + w;
            this._elem.css({ 'width': dim + 'px', right: '0px', top: '0px'});
            if (lshow &amp;&amp; this._label.constructor === $.jqplot.AxisLabelRenderer) {
                this._label._elem.css('width', w + 'px');
            }
        }
        
    };
    
    /**
     * called with scope of axis
     * @param {object} pos
     * @param {object} offsets
     */ 
    $.jqplot.CategoryAxisRenderer.prototype.pack = function (pos, offsets) {
        
        var ticks = this._ticks,
            max = this.max,
            min = this.min,
            offmax = offsets.max,
            offmin = offsets.min,
            lshow = (this._label == null) ? false : this._label.show,
            i,
            j,
            p,
            pixellength,
            unitlength,
            t,
            shim,
            temp,
            val,
            labeledge,
            w,
            h,
            step,
            mid,
            count;

        for (p in pos) {
            this._elem.css(p, pos[p]);
        }
        
        this._offsets = offsets;
        
        // pixellength will be + for x axes and - for y axes becasue pixels always measured from top left.
        pixellength = offmax - offmin;
        unitlength = max - min;
        
        if (!this.reverse) {
            
            // point to unit and unit to point conversions references to Plot DOM element top left corner.
            
            this.u2p = function (u) {
                return (u - min) * pixellength / unitlength + offmin;
            };

            this.p2u = function (p) {
                return (p - offmin) * unitlength / pixellength + min;
            };
                    
            if (this.name === 'xaxis' || this.name === 'x2axis') {
                this.series_u2p = function (u) {
                    return (u - min) * pixellength / unitlength;
                };
                this.series_p2u = function (p) {
                    return p * unitlength / pixellength + min;
                };
            } else {
                this.series_u2p = function (u) {
                    return (u - max) * pixellength / unitlength;
                };
                this.series_p2u = function (p) {
                    return p * unitlength / pixellength + max;
                };
            }
            
        } else {
            
            // point to unit and unit to point conversions references to Plot DOM element top left corner.
            
            this.u2p = function (u) {
                return offmin + (max - u) * pixellength / unitlength;
            };

            this.p2u = function (p) {
                return min + (p - offmin) * unitlength / pixellength;
            };
                    
            if (this.name === 'xaxis' || this.name === 'x2axis') {
                this.series_u2p = function (u) {
                    return (max - u) * pixellength / unitlength;
                };
                this.series_p2u = function (p) {
                    return p * unitlength / pixellength + max;
                };
            } else {
                this.series_u2p = function (u) {
                    return (min - u) * pixellength / unitlength;
                };
                this.series_p2u = function (p) {
                    return p * unitlength / pixellength + min;
                };
            }

        }
        
        if (this.show) {
            
            if (this.name === 'xaxis' || this.name === 'x2axis') {
                
                for (i = 0; i &lt; ticks.length; i++) {
                    
                    t = ticks[i];
                    
                    if (t.show &amp;&amp; t.showLabel) {
                        
                        if (t.constructor === $.jqplot.CanvasAxisTickRenderer &amp;&amp; t.angle) {
                            
                            // will need to adjust auto positioning based on which axis this is.
                            temp = (this.name == 'xaxis') ? 1 : -1;
                            
                            switch (t.labelPosition) {
                            case 'auto':
                                // position at end
                                if (temp * t.angle &lt; 0) {
                                    shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                // position at start
                                } else {
                                    shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                                }
                                break;
                            case 'end':
                                shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                break;
                            case 'start':
                                shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                                break;
                            case 'middle':
                                shim = -t.getWidth() / 2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                break;
                            default:
                                shim = -t.getWidth() / 2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                break;
                            }
                            
                        } else {
                            shim = -t.getWidth() / 2;
                        }
                        
                        val = this.u2p(t.value) + shim + 'px';
                        
                        t._elem.css('left', val);
                        t.pack();
                    }
                }
                
                labeledge = ['bottom', 0];
                
                if (lshow) {
                    w = this._label._elem.outerWidth(true);
                    this._label._elem.css('left', offmin + pixellength / 2 - w / 2 + 'px');
                    if (this.name === 'xaxis') {
                        this._label._elem.css('bottom', '0px');
                        labeledge = ['bottom', this._label._elem.outerHeight(true)];
                    } else {
                        this._label._elem.css('top', '0px');
                        labeledge = ['top', this._label._elem.outerHeight(true)];
                    }
                    this._label.pack();
                }
                
                // draw the group labels
                step = parseInt(this._ticks.length / this.groups, 10) + 1;
                
                for (i = 0; i &lt; this._groupLabels.length; i++) {
                    
                    mid = 0;
                    count = 0;
                    
                    for (j = i * step; j &lt; (i + 1) * step; j++) {
                        
                        if (j >= this._ticks.length - 1) {
                            continue; // the last tick does not exist as there is no other group in order to have an empty one.
                        }
                        
                        if (this._ticks[j]._elem &amp;&amp; this._ticks[j].label !== " ") {
                            t = this._ticks[j]._elem;
                            p = t.position();
                            mid += p.left + t.outerWidth(true) / 2;
                            count++;
                        }
                        
                    }
                    mid = mid / count;
                    this._groupLabels[i].css({ 'left': (mid - this._groupLabels[i].outerWidth(true) / 2)});
                    this._groupLabels[i].css(labeledge[0], labeledge[1]);
                }
                
            } else {
                
                for (i = 0; i &lt; ticks.length; i++) {
                    
                    t = ticks[i];
                    
                    if (t.show &amp;&amp; t.showLabel) {
                        
                        if (t.constructor === $.jqplot.CanvasAxisTickRenderer &amp;&amp; t.angle) {
                            
                            // will need to adjust auto positioning based on which axis this is.
                            temp = (this.name === 'yaxis') ? 1 : -1;
                            
                            switch (t.labelPosition) {
                            case 'auto':
                                // position at end
                            case 'end':
                                if (temp * t.angle &lt; 0) {
                                    shim = -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2;
                                } else {
                                    shim = -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                                }
                                break;
                            case 'start':
                                if (t.angle > 0) {
                                    shim = -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2;
                                } else {
                                    shim = -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                                }
                                break;
                            case 'middle':
                                // if (t.angle > 0) {
                                //     shim = -t.getHeight() / 2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                // }
                                // else {
                                //     shim = -t.getHeight() / 2 - t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                                // }
                                shim = -t.getHeight() / 2;
                                break;
                            default:
                                shim = -t.getHeight() / 2;
                                break;
                            }
                            
                        } else {
                            shim = -t.getHeight() / 2;
                        }
                        
                        val = this.u2p(t.value) + shim + 'px';
                        
                        t._elem.css('top', val);
                        t.pack();
                    }
                }
                
                labeledge = ['left', 0];
                
                if (lshow) {
                    
                    h = this._label._elem.outerHeight(true);
                    
                    this._label._elem.css('top', offmax - pixellength / 2 - h / 2 + 'px');
                    if (this.name === 'yaxis') {
                        this._label._elem.css('left', '0px');
                        labeledge = ['left', this._label._elem.outerWidth(true)];
                    } else {
                        this._label._elem.css('right', '0px');
                        labeledge = ['right', this._label._elem.outerWidth(true)];
                    }
                    this._label.pack();
                }
                
                // draw the group labels, position top here, do left after label position.
                step = parseInt(this._ticks.length / this.groups, 10) + 1; // step is one more than before as we don't want to have overlaps in loops
                for (i = 0; i &lt; this._groupLabels.length; i++) {
                    
                    mid = 0;
                    count = 0;
                    
                    for (j = i * step; j &lt; (i + 1) * step; j++) { // j must never reach (i+1)*step as we don't want to have overlap between loops
                        if (j >= this._ticks.length - 1) {
                            continue; // the last tick does not exist as there is no other group in order to have an empty one.
                        }
                        
                        if (this._ticks[j]._elem &amp;&amp; this._ticks[j].label !== " ") {
                            t = this._ticks[j]._elem;
                            p = t.position();
                            mid += p.top + t.outerHeight() / 2;
                            count++;
                        }
                    }
                    
                    mid = mid / count;
                    
                    this._groupLabels[i].css({'top': mid - this._groupLabels[i].outerHeight() / 2});
                    this._groupLabels[i].css(labeledge[0], labeledge[1]);
                    
                }
            }
        }
    };
    
}(jQuery));
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Tue Jan 12 2016 09:37:25 GMT+0100 (CET) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
