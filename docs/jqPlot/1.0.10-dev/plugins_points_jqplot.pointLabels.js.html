<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>plugins/points/jqplot.pointLabels.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="$.jqplot.CanvasFontRenderer.html">CanvasFontRenderer</a><ul class='methods'><li data-type='method'><a href="$.jqplot.CanvasFontRenderer.html#draw">draw</a></li><li data-type='method'><a href="$.jqplot.CanvasFontRenderer.html#measure">measure</a></li></ul></li><li><a href="$.jqplot.CanvasOverlay.html">CanvasOverlay</a><ul class='methods'><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#.postPlotDraw">postPlotDraw</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#.postPlotInit">postPlotInit</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addDashedHorizontalLine">addDashedHorizontalLine</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addDashedVerticalLine">addDashedVerticalLine</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addHorizontalLine">addHorizontalLine</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addLine">addLine</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addRectangle">addRectangle</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addVerticalLine">addVerticalLine</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#addWorkItem">addWorkItem</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#clear">clear</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#draw">draw</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#getObject">getObject</a></li><li data-type='method'><a href="$.jqplot.CanvasOverlay.html#removeObject">removeObject</a></li></ul></li><li><a href="$.jqplot.CanvasTextRenderer.html">CanvasTextRenderer</a><ul class='methods'><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#draw">draw</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#fontWeight2Float">fontWeight2Float</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#getHeight">getHeight</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#getText">getText</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#getWidth">getWidth</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#init">init</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#letter">letter</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#measure">measure</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#normalizeFontSize">normalizeFontSize</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#setHeight">setHeight</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#setText">setText</a></li><li data-type='method'><a href="$.jqplot.CanvasTextRenderer.html#setWidth">setWidth</a></li></ul></li><li><a href="$.jqplot.EnhancedLegendRenderer.html">EnhancedLegendRenderer</a><ul class='methods'><li data-type='method'><a href="$.jqplot.EnhancedLegendRenderer.html#draw">draw</a></li><li data-type='method'><a href="$.jqplot.EnhancedLegendRenderer.html#init">init</a></li></ul></li><li><a href="Class_%2520jqPlot%250APlot%2520object%2520returned%2520by%2520call%2520to%2520$.jqplot.%2520%2520Handles%2520parsing%2520user%2520options,%250Acreating%2520sub%2520objects%2520(Axes,%2520legend,%2520title,%2520series)%2520and%2520rendering%2520the%2520plot..html">Class: jqPlot
Plot object returned by call to $.jqplot.  Handles parsing user options,
creating sub objects (Axes, legend, title, series) and rendering the plot.</a></li><li><a href="DashedHorizontalLine.html">DashedHorizontalLine</a></li><li><a href="DashedVerticalLine.html">DashedVerticalLine</a></li><li><a href="HorizontalLine.html">HorizontalLine</a></li><li><a href="jsDate.html">jsDate</a></li><li><a href="Line.html">Line</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="VerticalLine.html">VerticalLine</a></li><li><a href="WorkItem.html">WorkItem</a></li></ul><h3>Namespaces</h3><ul><li><a href="Configuration%2520options%2520that%2520will%2520be%2520used%2520as%2520defaults%2520for%2520all%2520instances%2520on%2520the%2520page..html">Configuration options that will be used as defaults for all instances on the page.</a></li><li><a href="Holds%2520localizations%2520for%2520month_day%2520names.%250A_p_jsDate%2520attempts%2520to%2520detect%2520locale%2520when%2520loaded%2520and%2520defaults%2520to%2520_en_.%250AIf%2520a%2520localization%2520is%2520detected%2520which%2520is%2520not%2520available,%2520jsDate%2520defaults%2520to%2520_en_.%250AAdditional%2520localizations%2520can%2520be%2520added%2520after%2520jsDate%2520loads.%2520%2520After%2520adding%2520a%2520localization,%250Acall%2520the%2520jsDate.regional.getLocale()%2520method.%2520%2520Currently,%2520en,%2520fr%2520and%2520de%2520are%2520defined.__p_%250A%250A_p_Localizations%2520must%2520be%2520an%2520object%2520and%2520have%2520the%2520following%2520properties%2520defined_%2520%2520monthNames,%2520monthNamesShort,%2520dayNames,%2520dayNamesShort%2520and%2520Localizations%2520are%2520added%2520like___p_%250A_pre%2520class=_code__%250AjsDate.regional._en_%2520=%2520%257B%250AmonthNames%2520%2520%2520%2520%2520%2520_%2520_January%2520February%2520March%2520April%2520May%2520June%2520July%2520August%2520September%2520October%2520November%2520December_.split(_%2520_),%250AmonthNamesShort%2520_%2520_Jan%2520Feb%2520Mar%2520Apr%2520May%2520Jun%2520Jul%2520Aug%2520Sep%2520Oct%2520Nov%2520Dec_.split(_%2520_),%250AdayNames%2520%2520%2520%2520%2520%2520%2520%2520_%2520_Sunday%2520Monday%2520Tuesday%2520Wednesday%2520Thursday%2520Friday%2520Saturday_.split(_%2520_),%250AdayNamesShort%2520%2520%2520_%2520_Sun%2520Mon%2520Tue%2520Wed%2520Thu%2520Fri%2520Sat_.split(_%2520_)%250A%257D;%250A__pre_%250A_p_After%2520adding%2520localizations,%2520call%2520_code_jsDate.regional.getLocale();__code_%2520to%2520update%2520the%2520locale%2520setting%2520with%2520the%250Anew%2520localizations.__p_.html">Holds localizations for month/day names.
<p>jsDate attempts to detect locale when loaded and defaults to 'en'.
If a localization is detected which is not available, jsDate defaults to 'en'.
Additional localizations can be added after jsDate loads.  After adding a localization,
call the jsDate.regional.getLocale() method.  Currently, en, fr and de are defined.</p>

<p>Localizations must be an object and have the following properties defined:  monthNames, monthNamesShort, dayNames, dayNamesShort and Localizations are added like:</p>
<pre class="code">
jsDate.regional['en'] = {
monthNames      : 'January February March April May June July August September October November December'.split(' '),
monthNamesShort : 'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec'.split(' '),
dayNames        : 'Sunday Monday Tuesday Wednesday Thursday Friday Saturday'.split(' '),
dayNamesShort   : 'Sun Mon Tue Wed Thu Fri Sat'.split(' ')
};
</pre>
<p>After adding localizations, call <code>jsDate.regional.getLocale();</code> to update the locale setting with the
new localizations.</p></a></li><li><a href="Namespace%2520to%2520hold%2520format%2520codes%2520and%2520format%2520shortcuts.%2520%2520_perl_%2520and%2520_php_%2520format%2520codes%2520%250Aand%2520shortcuts%2520are%2520defined%2520by%2520default.%2520%2520Additional%2520codes%2520and%2520shortcuts%2520can%2520be%250Aadded%2520like_%250A%250A_pre%2520class=_code__%250AjsDate.formats._perl_%2520=%2520%257B%250A%2520%2520%2520%2520_codes__%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520matcher_%2520_someregex_,%250A%2520%2520%2520%2520%2520%2520%2520%2520Y_%2520_fullYear_,%2520%2520__%2520name%2520of%2520_get_%2520method%2520without%2520the%2520_get_,%250A%2520%2520%2520%2520%2520%2520%2520%2520...,%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520__%2520more%2520codes%250A%2520%2520%2520%2520%257D,%250A%2520%2520%2520%2520_shortcuts__%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520F_%2520_%2525Y-%2525m-%2525d_,%250A%2520%2520%2520%2520%2520%2520%2520%2520...,%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520__%2520more%2520shortcuts%250A%2520%2520%2520%2520%257D%250A%257D;%250A__pre_%250A%250A_p_Additionally,%2520ISO%2520and%2520SQL%2520shortcuts%2520are%2520defined%2520and%2520can%2520be%2520accesses%2520via_%250A_code_jsDate.formats.ISO__code_%2520and%2520_code_jsDate.formats.SQL__code_.html">Namespace to hold format codes and format shortcuts.  "perl" and "php" format codes 
and shortcuts are defined by default.  Additional codes and shortcuts can be
added like:

<pre class="code">
jsDate.formats["perl"] = {
    "codes": {
        matcher: /someregex/,
        Y: "fullYear",  // name of "get" method without the "get",
        ...,            // more codes
    },
    "shortcuts": {
        F: '%Y-%m-%d',
        ...,            // more shortcuts
    }
};
</pre>

<p>Additionally, ISO and SQL shortcuts are defined and can be accesses via:
<code>jsDate.formats.ISO</code> and <code>jsDate.formats.SQL</code></a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">plugins/points/jqplot.pointLabels.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*jslint browser: true, plusplus: true, nomen: true, white: false, continue:true */
/*global jQuery, console, jqPlot */

/**
 * jqPlot
 * Pure JavaScript plotting plugin using jQuery
 *
 * Version: @VERSION
 * Revision: @REVISION
 *
 * Copyright (c) 2009-2013 Chris Leonello
 * jqPlot is currently available for use in all personal or commercial projects 
 * under both the MIT (http://www.opensource.org/licenses/mit-license.php) and GPL 
 * version 2.0 (http://www.gnu.org/licenses/gpl-2.0.html) licenses. This means that you can 
 * choose the license that best suits your project and use it accordingly. 
 *
 * Although not required, the author would appreciate an email letting him 
 * know of any substantial use of jqPlot.  You can reach the author at: 
 * chris at jqplot dot com or see http://www.jqplot.com/info.php .
 *
 * If you are feeling kind and generous, consider supporting the project by
 * making a donation at: http://www.jqplot.com/donate.php .
 *
 * sprintf functions contained in jqplot.sprintf.js by Ash Searle:
 *
 *     version 2007.04.27
 *     author Ash Searle
 *     http://hexmen.com/blog/2007/03/printf-sprintf/
 *     http://hexmen.com/js/sprintf.js
 *     The author (Ash Searle) has placed this code in the public domain:
 *     "This code is unrestricted: you are free to use it however you like."
 * 
 */
(function ($) {
    
    "use strict";
    
    var locationIndicies = {'nw': 0, 'n': 1, 'ne': 2, 'e': 3, 'se': 4, 's': 5, 'sw': 6, 'w': 7},
        oppositeLocations = ['se', 's', 'sw', 'w', 'nw', 'n', 'ne', 'e'];
    
    /**
     * Class: $.jqplot.PointLabels
     * Plugin for putting labels at the data points.
     * 
     * To use this plugin, include the js
     * file in your source:
     * 
     * > &lt;script type="text/javascript" src="plugins/jqplot.pointLabels.js">&lt;/script>
     * 
     * By default, the last value in the data ponit array in the data series is used
     * for the label.  For most series renderers, extra data can be added to the 
     * data point arrays and the last value will be used as the label.
     * 
     * For instance, 
     * this series:
     * 
     * > [[1,4], [3,5], [7,2]]
     * 
     * Would, by default, use the y values in the labels.
     * Extra data can be added to the series like so:
     * 
     * > [[1,4,'mid'], [3 5,'hi'], [7,2,'low']]
     * 
     * And now the point labels would be 'mid', 'low', and 'hi'.
     * 
     * Options to the point labels and a custom labels array can be passed into the
     * "pointLabels" option on the series option like so:
     * 
     * > series:[{pointLabels:{
     * >    labels:['mid', 'hi', 'low'],
     * >    location:'se',
     * >    ypadding: 12
     * >    }
     * > }]
     * 
     * A custom labels array in the options takes precendence over any labels
     * in the series data.  If you have a custom labels array in the options,
     * but still want to use values from the series array as labels, set the
     * "labelsFromSeries" option to true.
     * 
     * By default, html entities (&lt;, >, etc.) are escaped in point labels.  
     * If you want to include actual html markup in the labels, 
     * set the "escapeHTML" option to false.
     * 
     */
    $.jqplot.PointLabels = function (options) {
        // Group: Properties
        //
        // prop: show
        // show the labels or not.
        this.show = $.jqplot.config.enablePlugins;
        // prop: location
        // compass location where to position the label around the point.
        // 'n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'
        this.location = 'n';
        // prop: labelsFromSeries
        // true to use labels within data point arrays.
        this.labelsFromSeries = false;
        // prop: seriesLabelIndex
        // array index for location of labels within data point arrays.
        // if null, will use the last element of the data point array.
        this.seriesLabelIndex = null;
        // prop: labels
        // array of arrays of labels, one array for each series.
        this.labels = [];
        // actual labels that will get displayed.
        // needed to preserve user specified labels in labels array.
        this._labels = [];
        // prop: stackedValue
        // true to display value as stacked in a stacked plot.
        // no effect if labels is specified.
        this.stackedValue = false;
        // prop: ypadding
        // vertical padding in pixels between point and label
        this.ypadding = 6;
        // prop: xpadding
        // horizontal padding in pixels between point and label
        this.xpadding = 6;
        // prop: escapeHTML
        // true to escape html entities in the labels.
        // If you want to include markup in the labels, set to false.
        this.escapeHTML = true;
        // prop: edgeTolerance
        // Number of pixels that the label must be away from an axis
        // boundary in order to be drawn.  Negative values will allow overlap
        // with the grid boundaries.
        this.edgeTolerance = -5;
        // prop: formatter
        // A class of a formatter for the tick text.  sprintf by default.
        this.formatter = $.jqplot.DefaultTickFormatter;
        // prop: formatString
        // string passed to the formatter.
        this.formatString = '';
        // prop: hideZeros
        // true to not show a label for a value which is 0.
        this.hideZeros = false;
        this._elems = [];
        // prop: darkColor
        this.darkColor = "#000";
        // prop: brightColor
        this.brightColor = "#EEE";
        // prop: checkColorBrightnessLevel
        // true to check the color value levels
        this.checkColorBrightnessLevel = false;
        
        $.extend(true, this, options);
    };
    
    /**
     * called with scope of a series
     * @param {object} target         [[Description]]
     * @param {array} data           [[Description]]
     * @param {object} seriesDefaults [[Description]]
     * @param {object} opts           [[Description]]
     * @param {Object}   plot           [[Description]]
     */
    $.jqplot.PointLabels.init = function (target, data, seriesDefaults, opts, plot) {
        var options = $.extend(true, {}, seriesDefaults, opts);
        options.pointLabels = options.pointLabels || {};
        if (this.renderer.constructor === $.jqplot.BarRenderer &amp;&amp; this.barDirection === 'horizontal' &amp;&amp; !options.pointLabels.location) {
            options.pointLabels.location = 'e';
        }
        // add a pointLabels attribute to the series plugins
        this.plugins.pointLabels = new $.jqplot.PointLabels(options.pointLabels);
        this.plugins.pointLabels.setLabels.call(this);
    };
    
    /**
     * called with scope of series
     */
    $.jqplot.PointLabels.prototype.setLabels = function () {
        
        var p = this.plugins.pointLabels,
            labelIdx,
            d,
            i;
        
        if (p.seriesLabelIndex !== null) {
            labelIdx = p.seriesLabelIndex;
        } else if (this.renderer.constructor === $.jqplot.BarRenderer &amp;&amp; this.barDirection === 'horizontal') {
            labelIdx = (this._plotData[0].length &lt; 3) ? 0 : this._plotData[0].length - 1;
        } else {
            labelIdx = (this._plotData.length === 0) ? 0 : this._plotData[0].length - 1;
        }
        
        p._labels = [];
        
        if (p.labels.length === 0 || p.labelsFromSeries) {
            if (p.stackedValue) {
                if (this._plotData.length &amp;&amp; this._plotData[0].length) {
                    // var idx = p.seriesLabelIndex || this._plotData[0].length -1;
                    for (i = 0; i &lt; this._plotData.length; i++) {
                        p._labels.push(this._plotData[i][labelIdx]);
                    }
                }
            } else {
                // var d = this._plotData;
                d = this.data;
                if (this.renderer.constructor === $.jqplot.BarRenderer &amp;&amp; this.waterfall) {
                    d = this._data;
                }
                if (d.length &amp;&amp; d[0].length) {
                    // var idx = p.seriesLabelIndex || d[0].length -1;
                    for (i = 0; i &lt; d.length; i++) {
                        p._labels.push(d[i][labelIdx]);
                    }
                }
                d = null;
            }
        } else if (p.labels.length) {
            p._labels = p.labels;
        }
    };
    
    /**
     * [[Description]]
     * @param   {object} elem                     [[Description]]
     * @param   {string} [location=this.location] [[Description]]
     * @param   {number} [padding=this.xpadding]  [[Description]]
     * @returns {number} [[Description]]
     */
    $.jqplot.PointLabels.prototype.xOffset = function (elem, location, padding) {
        
        var offset;
        
        location = location || this.location;
        padding = padding || this.xpadding;
        
        switch (location) {
        case 'nw':
            offset = -elem.outerWidth(true) - this.xpadding;
            break;
        case 'n':
            offset = -elem.outerWidth(true) / 2;
            break;
        case 'ne':
            offset =  this.xpadding;
            break;
        case 'e':
            offset = this.xpadding;
            break;
        case 'se':
            offset = this.xpadding;
            break;
        case 's':
            offset = -elem.outerWidth(true) / 2;
            break;
        case 'sw':
            offset = -elem.outerWidth(true) - this.xpadding;
            break;
        case 'w':
            offset = -elem.outerWidth(true) - this.xpadding;
            break;
        default: // same as 'nw'
            offset = -elem.outerWidth(true) - this.xpadding;
            break;
        }
        return offset;
    };
    
    /**
     * [[Description]]
     * @param   {object} elem                     [[Description]]
     * @param   {string} [location=this.location] [[Description]]
     * @param   {number} [padding=this.xpadding]  [[Description]]
     * @returns {number} [[Description]]
     */
    $.jqplot.PointLabels.prototype.yOffset = function (elem, location, padding) {
        
        var offset;
        
        location = location || this.location;
        padding = padding || this.xpadding;
        
        switch (location) {
        case 'nw':
            offset = -elem.outerHeight(true) - this.ypadding;
            break;
        case 'n':
            offset = -elem.outerHeight(true) - this.ypadding;
            break;
        case 'ne':
            offset = -elem.outerHeight(true) - this.ypadding;
            break;
        case 'e':
            offset = -elem.outerHeight(true) / 2;
            break;
        case 'se':
            offset = this.ypadding;
            break;
        case 's':
            offset = this.ypadding;
            break;
        case 'sw':
            offset = this.ypadding;
            break;
        case 'w':
            offset = -elem.outerHeight(true) / 2;
            break;
        default: // same as 'nw'
            offset = -elem.outerHeight(true) - this.ypadding;
            break;
        }
        return offset;
    };

    /**
     * called with scope of series
     * @param {Object}   sctx    [[Description]]
     * @param {object} options [[Description]]
     * @param {Object}   plot    [[Description]]
     */
    $.jqplot.PointLabels.draw = function (sctx, options, plot) {
        
		var i,
            len,
            p = this.plugins.pointLabels,
			pd = this._plotData,
			xax = this._xaxis,
			yax = this._yaxis,
			elem,
            helem,
            that = this,
            ax,
            label,
            location,
            ell,
            elt,
            elr,
            elb,
            et,
            scl,
            sct,
            scr,
            scb,
            barPoint,
            serieColor;

        // set labels again in case they have changed.
        p.setLabels.call(this);
        
        // remove any previous labels
        for (i = 0, len = p._elems.length; i &lt; len; i++) {
            // Memory Leaks patch
            // p._elems[i].remove();
            if (p._elems[i]) {
                p._elems[i].emptyForce();
            }
        }
        
        p._elems.splice(0, p._elems.length);

        if (p.show) {
            
            ax = '_' + this._stackAxis + 'axis';
        
            if (!p.formatString) {
                p.formatString = this[ax]._ticks[0].formatString;
                p.formatter = this[ax]._ticks[0].formatter;
            }

            for (i = 0, len = p._labels.length; i &lt; len; i++) {
                
                label = p._labels[i];
                location = p.location;
                
                if (label === null || (p.hideZeros &amp;&amp; parseInt(label, 10) === 0)) {
                    continue;
                }
                
                label = p.formatter(p.formatString, label);

                helem = document.createElement('div');
                p._elems[i] = $(helem);

                elem = p._elems[i];

                elem
                    .addClass('jqplot-point-label jqplot-series-' + this.index + ' jqplot-point-' + i)
                    .css('position', 'absolute');
                
                serieColor = (this._dataColors &amp;&amp; this._dataColors[i]) ? this._dataColors[i] : this.color;
                
                //console.log("checking color", serieColor);
                
                // Set the color of the label element when it matters
                // @TODO: check contrast between background and foreground colors
                if ((this.barDirection === "horizontal" &amp;&amp; p.location === "w") || p.checkColorBrightnessLevel) {
                    if (!$.jqplot.isDarkColor(serieColor)) {
                        elem.addClass('jqplot-point-darkColor');
                        if (p.darkColor !== null) {
                            elem.css('color', p.darkColor);
                        }
                    } else {
                        elem.addClass('jqplot-point-brightColor');
                        if (p.brightColor !== null) {
                            elem.css('color', p.brightColor);
                        }
                    }
                }

                elem.insertAfter(sctx.canvas);

                if (p.escapeHTML) {
                    elem.text(label);
                } else {
                    elem.html(label);
                }

                if ((this.fillToZero &amp;&amp; pd[i][1] &lt; 0) || (this.fillToZero &amp;&amp; this._type === 'bar' &amp;&amp; this.barDirection === 'horizontal' &amp;&amp; pd[i][0] &lt; 0) || (this.waterfall &amp;&amp; parseInt(label, 10)) &lt; 0) {
                    location = oppositeLocations[locationIndicies[location]];
                }

                ell = xax.u2p(pd[i][0]) + p.xOffset(elem, location);
                elt = yax.u2p(pd[i][1]) + p.yOffset(elem, location);

                // we have stacked chart but are not showing stacked values,
                // place labels in center.
                if (this._stack &amp;&amp; !p.stackedValue) {
                    barPoint = that._barPoints[i];
                    if (this.barDirection === "vertical") {
                        elt = (barPoint[0][1] + barPoint[1][1]) / 2 + plot._gridPadding.top - 0.5 * elem.outerHeight(true);
                        ell = (barPoint[2][0] + barPoint[0][0]) / 2 + plot._gridPadding.left - 0.5 * elem.outerWidth(true);
                    } else {
                        ell = (barPoint[2][0] + barPoint[0][0]) / 2 + plot._gridPadding.left - 0.5 * elem.outerWidth(true);
                    }
                }

                if (this.renderer.constructor === $.jqplot.BarRenderer) {
                    if (this.barDirection === "vertical") {
                        ell += this._barNudge;
                    } else {
                        elt -= this._barNudge;
                    }
                }
                
                elem.css({'left': ell, 'top': elt });

                elr = ell + elem.width();
                elb = elt + elem.height();
                et = p.edgeTolerance;
                scl = $(sctx.canvas).position().left;
                sct = $(sctx.canvas).position().top;
                scr = sctx.canvas.width + scl;
                scb = sctx.canvas.height + sct;
                // if label is outside of allowed area, remove it
                /*if (ell - et &lt; scl || elt - et &lt; sct || elr + et > scr || elb + et > scb) {
                    elem.remove();
                }*/

                elem = null;
                helem = null;
            }

            // finally, animate them if the series is animated
            // if (this.renderer.animation &amp;&amp; this.renderer.animation._supported &amp;&amp; this.renderer.animation.show &amp;&amp; plot._drawCount &lt; 2) {
            //     var sel = '.jqplot-point-label.jqplot-series-'+this.index;
            //     $(sel).hide();
            //     $(sel).fadeIn(1000);
            // }

        }
    };
    
    $.jqplot.postSeriesInitHooks.push($.jqplot.PointLabels.init);
    $.jqplot.postDrawSeriesHooks.push($.jqplot.PointLabels.draw);
    
}(jQuery));</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Tue Jan 12 2016 09:37:25 GMT+0100 (CET) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
